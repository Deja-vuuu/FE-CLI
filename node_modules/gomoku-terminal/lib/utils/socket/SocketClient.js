"use strict";
/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-01-09 21:55:09
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const mobx_1 = require("mobx");
const consts_1 = require("monofile-utilities/lib/consts");
const tiny_emitter_1 = require("tiny-emitter");
const uid_1 = require("../misc/uid");
const ErrorCode_1 = require("../service/ErrorCode");
const ServiceError_1 = require("../service/ServiceError");
const protocol_1 = require("./protocol");
const types_1 = require("./types");
const EVENT_LIST = Object.keys(types_1.SocketEvents).map((k) => types_1.SocketEvents[k]);
class SocketClient extends tiny_emitter_1.TinyEmitter {
    constructor({ url, maxReconnectCount = 7, connectTimeout = consts_1.T_SECOND, reconnectDelay = 3 * consts_1.T_SECOND, requestTimeout = consts_1.T_SECOND, }) {
        super();
        this.ws = null;
        this.readyTimer = null;
        this.retryLimit = 0;
        this.reconnectTimer = null;
        this.status = 'disconnected';
        this.latency = 0;
        this.clockOffset = 0;
        this.uid = uid_1.uid();
        this.reqs = {};
        this.url = url;
        this.maxReconnectCount = maxReconnectCount;
        this.connectTimeout = connectTimeout;
        this.reconnectDelay = reconnectDelay;
        this.requestTimeout = requestTimeout;
    }
    destroy() {
        this.readyTimer && clearTimeout(this.readyTimer);
        this.readyTimer = null;
        this.reconnectTimer && clearTimeout(this.reconnectTimer);
        this.reconnectTimer = null;
        const ws = this.ws;
        this.ws = null;
        if (!ws) {
            return;
        }
        ws.onopen = ws.onmessage = ws.onerror = ws.onclose = null;
        try {
            ws.close();
        }
        catch (_a) { }
    }
    open(reason, directly = false) {
        this.latency = 0;
        if (this.retryLimit <= 0) {
            this.disconnect();
            return;
        }
        if (this.retryLimit !== this.maxReconnectCount && !directly) {
            this.reconnectTimer = setTimeout(() => this.open(reason, true), this.reconnectDelay);
            return;
        }
        if (this.status !== 'connecting' && this.status !== 'reconnecting') {
            return;
        }
        const event = {
            count: this.maxReconnectCount - this.retryLimit + 1,
            total: this.maxReconnectCount,
            delay: this.reconnectDelay,
            reason: reason,
        };
        const key = this.status === 'reconnecting'
            ? types_1.SocketEvents.Reconnecting
            : types_1.SocketEvents.Connecting;
        this.emit(key, event);
        this.retryLimit -= 1;
        try {
            this.ws = new WebSocket(this.url);
        }
        catch (e) {
            this.open(e + '');
            return;
        }
        if (this.connectTimeout) {
            this.readyTimer = setTimeout(() => {
                this.destroy();
                this.open('ready timeout');
            }, this.connectTimeout);
        }
        this.ws.onerror = (ev) => this.reconnect({ type: ev.type });
        this.ws.onclose = (ev) => {
            if (ev.reason.substr(0, 4) === '[63]') {
                this.disconnect({ code: ev.code, reason: ev.reason.substr(4) });
            }
            else {
                this.reconnect({ code: ev.code, reason: ev.reason });
            }
        };
        this.ws.onmessage = mobx_1.action((event) => {
            const message = protocol_1.parse(event.data);
            if (message && message.key === types_1.SocketEvents.Ready) {
                this.readyTimer && clearTimeout(this.readyTimer);
                this.readyTimer = null;
                this.status = 'connected';
                this.emit(types_1.SocketEvents.Connected, message.data);
                this.ws.onmessage = ({ data }) => this.handleMessage(data);
            }
        });
    }
    reconnect(ev) {
        this.destroy();
        if (this.status === 'connected') {
            this.status = 'reconnecting';
            this.retryLimit = this.maxReconnectCount;
            this.open(ev);
        }
        else {
            this.open(ev);
        }
    }
    connect() {
        if (this.status !== 'disconnected') {
            return;
        }
        this.status = 'connecting';
        this.retryLimit = this.maxReconnectCount;
        this.open('user ask connect');
    }
    disconnect(event = {}) {
        event.status = this.status;
        this.status = 'disconnected';
        this.latency = 1024;
        this.destroy();
        this.retryLimit = 0;
        this.emit(types_1.SocketEvents.Disconnected, event);
    }
    is(status) {
        return this.status === status;
    }
    handleMessage(data) {
        const message = protocol_1.parse(data);
        this.emit(types_1.SocketEvents.Message, message, data);
        if (!message) {
            return;
        }
        switch (message.kind) {
            case protocol_1.MessageKind.Notify:
                this.emit(message.key, message.data, consts_1.noop);
                break;
            case protocol_1.MessageKind.Request:
                const st1 = Date.now();
                this.emit(message.key, message.data, (r) => this.ws.send(protocol_1.stringify({
                    kind: protocol_1.MessageKind.Response,
                    key: message.key,
                    id: message.id,
                    data: r,
                    st1,
                    st2: Date.now(),
                })));
                break;
            case protocol_1.MessageKind.Response:
                this.reqs[message.id] && this.reqs[message.id](message);
                break;
        }
    }
    request(key, data, id = this.uid()) {
        this.emit(types_1.SocketEvents.Send, protocol_1.MessageKind.Request, key, data, id);
        return new Promise((resolve, reject) => {
            if (this.status !== 'connected') {
                reject(new Error(this.status));
                return;
            }
            const ct0 = Date.now();
            const h = setTimeout(() => {
                delete this.reqs[id];
                reject(new ServiceError_1.ServiceError(ErrorCode_1.ResponseTimeout));
            }, this.connectTimeout);
            this.reqs[id] = mobx_1.action(({ data, st2, st1 }) => {
                delete this.reqs[id];
                clearTimeout(h);
                const ct3 = Date.now();
                this.latency = protocol_1.latency(ct0, st1, st2, ct3);
                this.clockOffset = protocol_1.offset(ct0, st1, st2, ct3);
                if (data && data.code && data.message) {
                    reject(new ServiceError_1.ServiceError(data.code, data.message));
                }
                resolve(data);
            });
            this.ws.send(protocol_1.stringify({
                kind: protocol_1.MessageKind.Request,
                id: id,
                key: key,
                data: data,
            }));
        });
    }
    notify(key, data, id = this.uid()) {
        this.emit(types_1.SocketEvents.Send, protocol_1.MessageKind.Notify, key, data, id);
        if (this.status !== 'connected') {
            throw new Error(this.status);
        }
        this.ws.send(protocol_1.stringify({ kind: protocol_1.MessageKind.Notify, key, data, id }));
    }
    use(key, callback, once = false) {
        if (__DEV__) {
            if (key.indexOf('socket/') === 0) {
                throw new Error('Please do not use socket/ as key, it is private');
            }
        }
        if (once) {
            super.once(key, callback);
        }
        else {
            super.on(key, callback);
        }
    }
    emit(key, ...args) {
        return super.emit(key, ...args);
    }
    on(key, callback, once = false) {
        if (__DEV__) {
            if (EVENT_LIST.indexOf(key) === -1) {
                throw new Error('Please use use(...) to register message callback');
            }
        }
        if (once) {
            super.once(key, callback);
        }
        else {
            super.on(key, callback);
        }
        return this;
    }
    once() {
        throw new Error('Please use on(key, callback, once) to register');
    }
}
tslib_1.__decorate([
    mobx_1.observable
], SocketClient.prototype, "status", void 0);
tslib_1.__decorate([
    mobx_1.observable
], SocketClient.prototype, "latency", void 0);
tslib_1.__decorate([
    mobx_1.observable
], SocketClient.prototype, "clockOffset", void 0);
tslib_1.__decorate([
    mobx_1.action
], SocketClient.prototype, "open", null);
tslib_1.__decorate([
    mobx_1.action
], SocketClient.prototype, "reconnect", null);
tslib_1.__decorate([
    mobx_1.action
], SocketClient.prototype, "connect", null);
tslib_1.__decorate([
    mobx_1.action
], SocketClient.prototype, "disconnect", null);
exports.SocketClient = SocketClient;
