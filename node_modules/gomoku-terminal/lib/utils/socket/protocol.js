"use strict";
/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-01-10 23:33:37
 *
 * message:
 *  <kind><id>
 *  <key>
 *  <payload>
 *
 * <kind>: p(ping), q(request), s(response), n(notify)
 * <id>: [0x0000, 0xffff]
 * <key>: anything without \n
 * <payload>: JSON stringify data
 *
 * 如果要扩展, 则在 <key> 后, <payload> 前面添加
 *
 * 如果 kind 为 Response, 则 key 为 cts:sts
 *
 * 确定网络延迟办法:
 *
 * 只能由发送方确定, 接收方无法计算, 这是有理由的, 服务端永远不需要关心客户端的延迟.
 * 1. 客户端在发送 Request 时, 记下本次请求的本地时间戳 ct0
 * 2. 服务端在收到消息时, 记录收到消息时服务端时间戳 st1
 * 3. 服务端在返回消息时, 记录发送消息时服务端时间戳 st2
 * 4. Response 中包含 st1:st2
 * 5. 客户端记录收到消息时本地时间戳: ct3
 *
 * 延迟(HTT) = ((ct3 - ct0) - (st2 - st1)) / 2
 * 钟差(CO, CT + CO = ST) = ((st1 - ct0 - HTT) + (st2 - ct3 + HTT)) / 2
 *                 = (st1 - ct0 + st2 - ct3) / 2
 */
Object.defineProperty(exports, "__esModule", { value: true });
function latency(ct0, st1, st2, ct3) {
    return ct3 - ct0 - (st2 - st1);
}
exports.latency = latency;
function offset(ct0, st1, st2, ct3) {
    return (st1 - ct0 + st2 - ct3) / 2;
}
exports.offset = offset;
const enum_1 = require("monofile-utilities/lib/enum");
const numberFormat_1 = require("../misc/numberFormat");
var MessageKind;
(function (MessageKind) {
    MessageKind["Request"] = "q";
    MessageKind["Response"] = "s";
    MessageKind["Notify"] = "n";
})(MessageKind = exports.MessageKind || (exports.MessageKind = {}));
exports.MessageKindValues = enum_1.enumValues(MessageKind);
exports.MessageKindKeys = enum_1.enumKeys(MessageKind);
exports.MessageKindLabels = exports.MessageKindValues.reduce((prev, now, index) => {
    prev[now] = exports.MessageKindKeys[index];
    return prev;
}, {});
function stringify({ kind, key, id, data, st1, st2 }) {
    if (kind === MessageKind.Response) {
        key = `${numberFormat_1.itos(st1)}:${numberFormat_1.itos(st2)}`;
    }
    if (data === void 0) {
        return `${kind}${id}\n${key}`;
    }
    if (typeof data !== 'string') {
        data = JSON.stringify(data);
    }
    return `${kind}${id}\n${key}\n${data}`;
}
exports.stringify = stringify;
function parse(event) {
    if (typeof event !== 'string') {
        parse.lastError = 'does not support binary message';
        return null;
    }
    const [head, key, payload] = event.split('\n', 3);
    const kind = head.charAt(0);
    const id = head.substr(1);
    if (exports.MessageKindValues.indexOf(kind) === -1) {
        parse.lastError = `message kind "${kind}" is invalid`;
        return null;
    }
    let data;
    if (payload) {
        try {
            data = JSON.parse(payload);
        }
        catch (e) {
            parse.lastError = `message payload is invalid JSON`;
            return null;
        }
    }
    const msg = { kind, id, key, data };
    if (kind === MessageKind.Response) {
        const [t1, t2] = key.split(':', 2);
        msg.st1 = numberFormat_1.stoi(t1);
        msg.st2 = numberFormat_1.stoi(t2);
    }
    return msg;
}
exports.parse = parse;
parse.lastError = '';
