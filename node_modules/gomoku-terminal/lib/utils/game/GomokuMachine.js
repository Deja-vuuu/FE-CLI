"use strict";
/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-01-31 20:37:50
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const dayjs_1 = tslib_1.__importDefault(require("dayjs"));
const GameService_idl_1 = require("../../types/GameService.idl");
const GomokuService_idl_1 = require("../../types/GomokuService.idl");
const ServiceError_1 = require("../service/ServiceError");
const board_put_1 = require("./board_put");
var Piece;
(function (Piece) {
    Piece[Piece["Empty"] = 0] = "Empty";
    Piece[Piece["Black"] = 1] = "Black";
    Piece[Piece["White"] = 2] = "White";
})(Piece = exports.Piece || (exports.Piece = {}));
const BOARD_SIZE = 15;
class GomokuMachine {
    constructor(game) {
        this.id = game.id;
        this.createdAt = dayjs_1.default(game.createdAt).valueOf();
        this.winner = null;
        this.winnerLocation = null;
        this.board = new board_put_1.Board(15, 15, Piece.Empty);
        this.history = board_put_1.boardDecodeRecord(game.record || '');
    }
    computeWinner() {
        const { x, y } = this.history[this.history.length - 1];
        const winner = this.history.length % 2 ? GomokuService_idl_1.GomokuRole.BLACK : GomokuService_idl_1.GomokuRole.WHITE;
        let i;
        let j;
        let ok = true;
        for (i = 1; i < 5; i++) {
            if (x + i >= BOARD_SIZE ||
                this.board.get(x + i, y) !== this.board.get(x, y)) {
                break;
            }
        }
        for (j = 5 - i; j > 0; j--) {
            if (x - j < 0 || this.board.get(x - j, y) !== this.board.get(x, y)) {
                ok = false;
                break;
            }
        }
        if (ok) {
            this.winner = winner;
            this.winnerLocation = [[x + i - 5, y], [x + i - 1, y]];
            return winner;
        }
        ok = true;
        for (i = 1; i < 5; i++) {
            if (y - i < 0 ||
                x + i >= BOARD_SIZE ||
                this.board.get(x + i, y - i) !== this.board.get(x, y)) {
                break;
            }
        }
        for (j = 5 - i; j > 0; j--) {
            if (y + j >= BOARD_SIZE ||
                x - j < 0 ||
                this.board.get(x - j, y + j) !== this.board.get(x, y)) {
                ok = false;
                break;
            }
        }
        if (ok) {
            this.winner = winner;
            this.winnerLocation = [[x + i - 5, y + 5 - i], [x + i - 1, y + 1 - i]];
            return winner;
        }
        ok = true;
        for (i = 1; i < 5; i++) {
            if (y - i < 0 || this.board.get(x, y - i) !== this.board.get(x, y)) {
                break;
            }
        }
        for (j = 5 - i; j > 0; j--) {
            if (y + j >= BOARD_SIZE ||
                this.board.get(x, y + j) !== this.board.get(x, y)) {
                ok = false;
                break;
            }
        }
        if (ok) {
            this.winner = winner;
            this.winnerLocation = [[x, y - i + 1], [x, y + 5 - i]];
            return winner;
        }
        ok = true;
        for (i = 1; i < 5; i++) {
            if (y - i < 0 ||
                x - i < 0 ||
                this.board.get(x - i, y - i) !== this.board.get(x, y)) {
                break;
            }
        }
        for (j = 5 - i; j > 0; j--) {
            if (y + j >= BOARD_SIZE ||
                x + j >= BOARD_SIZE ||
                this.board.get(x + j, y + j) !== this.board.get(x, y)) {
                ok = false;
                break;
            }
        }
        if (ok) {
            this.winner = winner;
            this.winnerLocation = [[x - i + 1, y - i + 1], [x + i - 5, y + i - 5]];
            return winner;
        }
        return null;
    }
    go(role, event) {
        if (this.winner !== null ||
            event.gameId !== this.id ||
            event.index !== this.history.length) {
            throw new ServiceError_1.ServiceError(GameService_idl_1.InvalidGameStatus);
        }
        if ((role === 'BLACK') !== (this.history.length % 2 === 0)) {
            throw new ServiceError_1.ServiceError(GameService_idl_1.InvalidUserRound);
        }
        const [x, y] = event.location;
        if (this.board.get(x, y) !== Piece.Empty) {
            throw new ServiceError_1.ServiceError(GameService_idl_1.InvalidBoardLocation);
        }
        this.board.set(x, y, this.history.length % 2 ? Piece.White : Piece.Black);
        const hand = { x, y, t: Date.now() - this.createdAt };
        this.history.push(hand);
        this.computeWinner();
        return hand;
    }
}
exports.GomokuMachine = GomokuMachine;
