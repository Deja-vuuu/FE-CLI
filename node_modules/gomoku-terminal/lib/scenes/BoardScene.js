"use strict";
/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-04-12 16:04:48
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const ink_1 = require("ink");
const lodash_1 = require("lodash");
const mobx_1 = require("mobx");
const custom_1 = require("mobx-react/custom");
const consts_1 = require("monofile-utilities/lib/consts");
const React = tslib_1.__importStar(require("react"));
const react_1 = require("react");
const Focusable_1 = require("../components/Focusable");
const KeyboardReceiver_1 = require("../components/KeyboardReceiver");
const GomokuStore_1 = require("../store/GomokuStore");
const UserStore_1 = require("../store/UserStore");
const RoomModule_idl_1 = require("../types/RoomModule.idl");
const board_put_1 = require("../utils/game/board_put");
const GomokuMachine_1 = require("../utils/game/GomokuMachine");
const log_1 = require("../utils/misc/log");
const numberFormat_1 = require("../utils/misc/numberFormat");
const time_1 = require("../utils/misc/time");
const types_1 = require("../utils/socket/types");
const utils_1 = require("../utils/socket/utils");
const my = Array(15)
    .fill(0)
    .map((_, i) => i);
const mx = my.slice();
const chars = '⋅•◦';
let BoardScene = class BoardScene extends react_1.Component {
    constructor(props) {
        super(props);
        this.keys = KeyboardReceiver_1.ignoreCase('REPADG');
        this.labels = '0123456789ABCDE'.split('');
        this.board = new board_put_1.Board(15, 15, GomokuMachine_1.Piece.Empty);
        this.error = '';
        this.loading = false;
        this.handlePress = (key) => {
            switch (key.toUpperCase()) {
                case 'R':
                    this.handleReady();
                    break;
                case 'E':
                    this.handleExit();
                    break;
                case 'P':
                    this.handleAskPeace();
                    break;
                case 'A':
                    this.handleAccept();
                    break;
                case 'D':
                    this.handleDecline();
                    break;
                case 'G':
                    this.handleGiveUp();
                    break;
            }
        };
        this.handleExit = () => tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.loading) {
                return;
            }
            if (this.me.status === RoomModule_idl_1.RoomUserStatus.Playing) {
                return;
            }
            this.set(void 0, true);
            try {
                yield GomokuStore_1.Gomoku.socket.request('room.exit', void 0);
                GomokuStore_1.Gomoku.push('RoomList');
            }
            catch (e) {
                this.set(e + '', false);
            }
        });
        this.handleReady = () => tslib_1.__awaiter(this, void 0, void 0, function* () {
            log_1.debug('handleReady', process.stdin.listenerCount('data'));
            if (this.loading) {
                return;
            }
            if (this.me.status !== RoomModule_idl_1.RoomUserStatus.Unready) {
                return;
            }
            this.set(void 0, true);
            try {
                yield GomokuStore_1.Gomoku.socket.request('room.ready');
                mobx_1.runInAction(() => {
                    this.me.status = RoomModule_idl_1.RoomUserStatus.Ready;
                    this.set('', false);
                });
            }
            catch (e) {
                this.set(e + '', false);
            }
        });
        this.handlePlay = lodash_1.memoize((x, y) => () => tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.loading) {
                return;
            }
            if (!GomokuStore_1.Gomoku.room.game ||
                !GomokuStore_1.Gomoku.room.game.action ||
                GomokuStore_1.Gomoku.room.game.action.userId !== this.me.id) {
                return;
            }
            this.set(void 0, true);
            try {
                const data = yield GomokuStore_1.Gomoku.socket.request('gomoku.play', {
                    index: GomokuStore_1.Gomoku.room.game.action.index,
                    gameId: GomokuStore_1.Gomoku.room.game.id,
                    location: [x, y],
                });
                mobx_1.runInAction(() => {
                    this.board.set(data.hand.x, data.hand.y, data.index % 2 ? GomokuMachine_1.Piece.White : GomokuMachine_1.Piece.Black);
                    GomokuStore_1.Gomoku.room.game.action = data.next;
                    this.set('', false);
                });
            }
            catch (e) {
                this.set(e + '', false);
            }
        }), (x, y) => x + '-' + y);
        this.handleAskPeace = () => tslib_1.__awaiter(this, void 0, void 0, function* () { });
        this.handleAccept = () => tslib_1.__awaiter(this, void 0, void 0, function* () { });
        this.handleDecline = () => tslib_1.__awaiter(this, void 0, void 0, function* () { });
        this.handleGiveUp = () => tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.loading) {
                return;
            }
            if (this.me.status !== RoomModule_idl_1.RoomUserStatus.Playing) {
                return;
            }
            this.set(void 0, true);
            try {
                yield GomokuStore_1.Gomoku.socket.request('gomoku.giveUp');
                this.set(void 0, false);
            }
            catch (e) {
                this.set(e + '', false);
            }
        });
        if (GomokuStore_1.Gomoku.room.game) {
            const initial = board_put_1.boardDecodeRecord(GomokuStore_1.Gomoku.room.game.record);
            initial.forEach((value, index) => {
                this.board.set(value.x, value.y, index % 2 ? GomokuMachine_1.Piece.White : GomokuMachine_1.Piece.Black);
            });
        }
    }
    set(error = this.error, loading = this.loading) {
        this.error = error;
        this.loading = loading;
    }
    get me() {
        return GomokuStore_1.Gomoku.room
            ? GomokuStore_1.Gomoku.room.players[0] && GomokuStore_1.Gomoku.room.players[0].id === UserStore_1.User.userId
                ? GomokuStore_1.Gomoku.room.players[0]
                : GomokuStore_1.Gomoku.room.players[1]
            : null;
    }
    get it() {
        return GomokuStore_1.Gomoku.room
            ? GomokuStore_1.Gomoku.room.players[0]
                ? GomokuStore_1.Gomoku.room.players[0].id === UserStore_1.User.userId
                    ? GomokuStore_1.Gomoku.room.players[1]
                    : GomokuStore_1.Gomoku.room.players[0]
                : null
            : null;
    }
    componentDidMount() {
        utils_1.mountHandlers(this, GomokuStore_1.Gomoku.socket);
        GomokuStore_1.Gomoku.socket.on(types_1.SocketEvents.Reconnecting, this.handleReconnect);
        this.updateTimer = setInterval(() => this.forceUpdate(), consts_1.T_SECOND);
    }
    componentWillUnmount() {
        utils_1.unmountHandlers(this, GomokuStore_1.Gomoku.socket);
        GomokuStore_1.Gomoku.socket.off(types_1.SocketEvents.Reconnecting, this.handleReconnect);
        clearInterval(this.updateTimer);
    }
    handleReconnect() {
        if (this.me.status !== RoomModule_idl_1.RoomUserStatus.Playing) {
            GomokuStore_1.Gomoku.push('RoomList');
        }
        else {
            this.me.offline = true;
        }
    }
    handleRoomEnter({ user }) {
        if (user.seat === undefined || user.status === RoomModule_idl_1.RoomUserStatus.View) {
            return;
        }
        GomokuStore_1.Gomoku.room.players[user.seat] = user;
    }
    handleRoomLeave({ user, }) {
        if (user.seat === undefined) {
            return;
        }
        if (user.id === UserStore_1.User.userId) {
            GomokuStore_1.Gomoku.push('RoomList');
            GomokuStore_1.Gomoku.room = consts_1.ANY;
        }
        else {
            GomokuStore_1.Gomoku.room.players[user.seat] = null;
        }
    }
    handleRoomAskReady({ user }) {
        GomokuStore_1.Gomoku.room.players[user.seat] = user;
    }
    handleRoomReady({ user }) {
        GomokuStore_1.Gomoku.room.players[user.seat] = user;
    }
    handleRoomUnready({ user }) {
        GomokuStore_1.Gomoku.room.players[user.seat] = user;
    }
    handleGomokuStart(event) {
        this.board.data.fill(0);
        GomokuStore_1.Gomoku.room.game = event;
    }
    handleGomokuPlay(event) {
        this.board.set(event.hand.x, event.hand.y, event.index % 2 ? GomokuMachine_1.Piece.White : GomokuMachine_1.Piece.Black);
        GomokuStore_1.Gomoku.room.game.action = event.next;
    }
    handleGomokuAskPeace(event) { }
    handleGomokuReplyPeace(event) { }
    handleGomokuOver(event) {
        this.set(`Game Over, ${event.winner === null
            ? 'TIE'
            : (event.winner === 'BLACK') ===
                (this.me.id === GomokuStore_1.Gomoku.room.game.players[0].userId)
                ? 'YOU WIN'
                : 'YOU LOSE'}!`);
        GomokuStore_1.Gomoku.room.game = undefined;
    }
    handleSessionConnect({ user }) {
        if (user.status === RoomModule_idl_1.RoomUserStatus.View || user.seat === undefined) {
            return;
        }
        GomokuStore_1.Gomoku.room.players[user.seat] = user;
    }
    handleSessionDisconnect({ user }) {
        if (user.status === RoomModule_idl_1.RoomUserStatus.View || user.seat === undefined) {
            return;
        }
        GomokuStore_1.Gomoku.room.players[user.seat] = user;
    }
    render() {
        return (React.createElement(Focusable_1.FocusableContainer, null,
            React.createElement(ink_1.Box, { width: 71, flexDirection: "row" },
                React.createElement(KeyboardReceiver_1.KeyboardReceiver, { keys: this.keys, onPress: this.handlePress, focus: true }),
                React.createElement(ink_1.Box, { width: 20, flexDirection: "column", alignItems: "center" },
                    "Opponent",
                    `(${this.it ? this.it.id : '--'})`,
                    GomokuStore_1.Gomoku.room.game
                        ? GomokuStore_1.Gomoku.room.game.action &&
                            GomokuStore_1.Gomoku.room.game.action.userId === this.it.id
                            ? time_1.remains(GomokuStore_1.Gomoku.room.game.action.since, GomokuStore_1.Gomoku.room.game.action.timeout, GomokuStore_1.Gomoku.socket.clockOffset)
                            : ''
                        : this.it
                            ? this.it.status
                            : '',
                    this.it && this.it.offline ? 'Offline' : null),
                React.createElement(ink_1.Box, { width: 31, flexDirection: "column", alignItems: "center" },
                    React.createElement(ink_1.Color, { green: this.loading, red: !this.loading && !!this.error }, this.loading ? 'Doing...' : this.error || ' '),
                    ' ',
                    React.createElement(ink_1.Color, { gray: true }, '  ' + this.labels.join(' ')),
                    my.map((y) => {
                        return (React.createElement(ink_1.Box, { key: y, flexDirection: "row" },
                            React.createElement(ink_1.Color, { gray: true }, numberFormat_1.itos(y)),
                            mx.map((x) => (React.createElement(ink_1.Box, { key: x },
                                ' ',
                                React.createElement(Focusable_1.Focusable, { y: y, x: x, focusProps: Focusable_1.inputFocusProps },
                                    React.createElement(KeyboardReceiver_1.KeyboardReceiver, { onEnter: this.handlePlay(x, y) }, chars.charAt(this.board.get(x, y)))))))));
                    }),
                    React.createElement(ink_1.Box, { flexDirection: "row", justifyContent: "space-between" },
                        GomokuStore_1.Gomoku.room.game ? null : (React.createElement(Focusable_1.Focusable, { y: 16, x: 0, margin: 1, underline: true, focusProps: Focusable_1.btnFocusProps },
                            React.createElement(KeyboardReceiver_1.KeyboardReceiver, { onEnter: this.handleExit }, "Exit(E)"))),
                        this.me.status === RoomModule_idl_1.RoomUserStatus.Unready ? (React.createElement(Focusable_1.Focusable, { y: 16, x: 1, margin: 1, underline: true, focusProps: Focusable_1.btnFocusProps },
                            React.createElement(KeyboardReceiver_1.KeyboardReceiver, { onEnter: this.handleReady }, `Ready(R:${time_1.remains(this.me.since, GomokuStore_1.Gomoku.meta.prefab.readyTimeout * consts_1.T_SECOND, GomokuStore_1.Gomoku.socket.clockOffset)})`))) : null,
                        GomokuStore_1.Gomoku.room.game ? (React.createElement(Focusable_1.Focusable, { y: 16, x: 2, margin: 1, underline: true, focusProps: Focusable_1.btnFocusProps },
                            React.createElement(KeyboardReceiver_1.KeyboardReceiver, { onEnter: this.handleGiveUp }, "Give Up(Q)"))) : null)),
                React.createElement(ink_1.Box, { width: 20, flexDirection: "column-reverse", alignItems: "center" },
                    `Me(${UserStore_1.User.userId})`,
                    GomokuStore_1.Gomoku.room.game
                        ? GomokuStore_1.Gomoku.room.game.action &&
                            GomokuStore_1.Gomoku.room.game.action.userId === this.me.id
                            ? time_1.remains(GomokuStore_1.Gomoku.room.game.action.since, GomokuStore_1.Gomoku.room.game.action.timeout, GomokuStore_1.Gomoku.socket.clockOffset)
                            : ''
                        : this.me
                            ? this.me.status
                            : ''))));
    }
};
tslib_1.__decorate([
    mobx_1.observable
], BoardScene.prototype, "error", void 0);
tslib_1.__decorate([
    mobx_1.observable
], BoardScene.prototype, "loading", void 0);
tslib_1.__decorate([
    mobx_1.action
], BoardScene.prototype, "set", null);
tslib_1.__decorate([
    mobx_1.computed
], BoardScene.prototype, "me", null);
tslib_1.__decorate([
    mobx_1.computed
], BoardScene.prototype, "it", null);
tslib_1.__decorate([
    mobx_1.action.bound
], BoardScene.prototype, "handleReconnect", null);
tslib_1.__decorate([
    mobx_1.action.bound
], BoardScene.prototype, "handleRoomEnter", null);
tslib_1.__decorate([
    mobx_1.action.bound
], BoardScene.prototype, "handleRoomLeave", null);
tslib_1.__decorate([
    mobx_1.action.bound
], BoardScene.prototype, "handleRoomAskReady", null);
tslib_1.__decorate([
    mobx_1.action.bound
], BoardScene.prototype, "handleRoomReady", null);
tslib_1.__decorate([
    mobx_1.action.bound
], BoardScene.prototype, "handleRoomUnready", null);
tslib_1.__decorate([
    mobx_1.action.bound
], BoardScene.prototype, "handleGomokuStart", null);
tslib_1.__decorate([
    mobx_1.action.bound
], BoardScene.prototype, "handleGomokuPlay", null);
tslib_1.__decorate([
    mobx_1.action.bound
], BoardScene.prototype, "handleGomokuAskPeace", null);
tslib_1.__decorate([
    mobx_1.action.bound
], BoardScene.prototype, "handleGomokuReplyPeace", null);
tslib_1.__decorate([
    mobx_1.action.bound
], BoardScene.prototype, "handleGomokuOver", null);
tslib_1.__decorate([
    mobx_1.action.bound
], BoardScene.prototype, "handleSessionConnect", null);
tslib_1.__decorate([
    mobx_1.action.bound
], BoardScene.prototype, "handleSessionDisconnect", null);
BoardScene = tslib_1.__decorate([
    custom_1.observer
], BoardScene);
exports.BoardScene = BoardScene;
