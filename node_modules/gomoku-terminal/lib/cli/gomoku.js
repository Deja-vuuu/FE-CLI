#!/usr/bin/env node
"use strict";
/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-04-12 16:02:42
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
global.__DEV__ = process.env.NODE_ENV === 'development';
global.WebSocket = require('ws');
require('mobx').configure({ enforceActions: __DEV__ ? 'observed' : 'never' });
require('mobx-sync').config({ ssr: false });
const ink_1 = require("ink");
const mobx_sync_1 = require("mobx-sync");
const react_1 = require("react");
const yargs_1 = tslib_1.__importDefault(require("yargs"));
const Application_1 = require("../scenes/Application");
const GomokuStore_1 = require("../store/GomokuStore");
const UserStore_1 = require("../store/UserStore");
const FSStorage_1 = require("../utils/misc/FSStorage");
const api_1 = require("../utils/service/api");
const expandHomeDir = require('expand-home-dir');
const argv = yargs_1.default
    .alias('help', 'h')
    .string('api')
    .default('api', 'http://23.106.139.99:5001')
    .describe('api', 'the api host')
    .string('store')
    .default('store', '~/.gomoku-terminal.json')
    .describe('store', 'the config & session store file')
    .usage('$0 [options]')
    .help().argv;
class Store {
    constructor() {
        this.user = new UserStore_1.UserStore().inject();
        this.gomoku = new GomokuStore_1.GomokuStore().inject();
    }
}
tslib_1.__decorate([
    mobx_sync_1.ignore
], Store.prototype, "gomoku", void 0);
function gomoku() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (process.stdout.columns < 71 || process.stdout.rows < 20) {
            console.warn('WARNING: your terminal size is less than 71(w) x 20(h), please resize your window.');
        }
        api_1.API.config({ host: argv.api });
        const storage = new FSStorage_1.FSStorage(expandHomeDir(argv.store));
        storage.init();
        process.on('exit', () => {
            console.log('exiting...');
            storage.destroy();
        });
        process.on('unhandledRejection', () => process.exit(1));
        process.on('uncaughtException', () => process.exit(1));
        const signals = [
            'SIGTERM',
            'SIGHUP',
            'SIGINT',
            'SIGQUIT',
            'SIGABRT',
        ];
        signals.forEach((signal) => process.on(signal, () => process.exit(0)));
        process.stdout.write('\u001bc');
        const store = new Store();
        const trunk = new mobx_sync_1.AsyncTrunk(store, { storage, delay: 50 });
        yield trunk.init();
        const ink = ink_1.render(react_1.createElement(Application_1.Application), { debug: false });
        yield ink.waitUntilExit();
    });
}
gomoku().catch((reason) => {
    console.error(reason);
    process.exit(1);
});
