"use strict";
/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-04-14 18:05:18
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const ink_1 = require("ink");
const mobx_1 = require("mobx");
const consts_1 = require("monofile-utilities/lib/consts");
const React = tslib_1.__importStar(require("react"));
const react_1 = require("react");
const array_1 = require("../utils/misc/array");
class FocusableStore {
    constructor() {
        this.container = undefined;
        this.current = undefined;
        this.items = mobx_1.observable.map();
    }
    get(x, y) {
        const row = this.items.get(y);
        return row ? row.get(x) : undefined;
    }
    row(y) {
        return this.items.get(y);
    }
    put(item) {
        if (!this.items.has(item.props.y)) {
            this.items.set(item.props.y, mobx_1.observable.map({}, { deep: false }));
        }
        this.items.get(item.props.y).set(item.props.x, item);
    }
    drop(item) {
        if (this.current === item) {
            this.current = undefined;
        }
        if (!this.items.has(item.props.y)) {
            return;
        }
        const row = this.items.get(item.props.y);
        if (row.get(item.props.x) === item) {
            row.delete(item.props.x);
        }
    }
    get ys() {
        return Array.from(this.items.keys())
            .filter((y) => this.items.get(y).size > 0)
            .sort((a, b) => a - b);
    }
    xs(y) {
        return this.items.has(y)
            ? Array.from(this.items.get(y).keys()).sort((a, b) => a - b)
            : [];
    }
    get minY() {
        return Math.min(...Array.from(this.items.keys()).filter((y) => this.items.get(y).size > 0));
    }
    get maxY() {
        return Math.max(...Array.from(this.items.keys()).filter((y) => this.items.get(y).size > 0));
    }
    get keys() {
        return Array.from(this.items.keys()).map((y) => ({
            row: y,
            cols: Array.from(this.items.get(y).keys()),
        }));
    }
}
tslib_1.__decorate([
    mobx_1.observable
], FocusableStore.prototype, "container", void 0);
tslib_1.__decorate([
    mobx_1.observable
], FocusableStore.prototype, "current", void 0);
tslib_1.__decorate([
    mobx_1.action
], FocusableStore.prototype, "put", null);
tslib_1.__decorate([
    mobx_1.action
], FocusableStore.prototype, "drop", null);
tslib_1.__decorate([
    mobx_1.computed
], FocusableStore.prototype, "ys", null);
tslib_1.__decorate([
    mobx_1.computed
], FocusableStore.prototype, "minY", null);
tslib_1.__decorate([
    mobx_1.computed
], FocusableStore.prototype, "maxY", null);
tslib_1.__decorate([
    mobx_1.computed
], FocusableStore.prototype, "keys", null);
const state = new FocusableStore();
const ARROW_UP = '\u001B[A';
const ARROW_DOWN = '\u001B[B';
const ARROW_LEFT = '\u001B[D';
const ARROW_RIGHT = '\u001B[C';
exports.inputFocusProps = {
    bgMagenta: true,
};
exports.btnFocusProps = { bgBlue: true };
class Focusable extends react_1.PureComponent {
    constructor() {
        super(...arguments);
        this.state = { focused: false };
    }
    componentWillReceiveProps(nextProps, nextContext) {
        if (__DEV__) {
            if (nextProps.x !== this.props.x || nextProps.y !== this.props.y) {
                throw new Error("You should not change focusable item's location");
            }
        }
    }
    componentDidMount() {
        state.put(this);
    }
    componentWillUnmount() {
        state.drop(this);
    }
    render() {
        const focusProps = this.state.focused ? this.props.focusProps : void 0;
        return (React.createElement(ink_1.Color, Object.assign({}, this.props, focusProps),
            React.createElement(ink_1.Box, Object.assign({}, this.props, focusProps), React.Children.map(this.props.children, (child) => {
                return React.isValidElement(child)
                    ? React.cloneElement(child, Object.assign({}, child.props, { focus: this.state.focused }))
                    : child;
            }))));
    }
}
exports.Focusable = Focusable;
class FocusableContainer extends react_1.PureComponent {
    constructor() {
        super(...arguments);
        this.stdin = consts_1.ANY;
        this.setRawMode = void 0;
    }
    left() {
        if (!state.current) {
            return {
                y: state.minY,
                x: state.xs(state.minY).pop(),
            };
        }
        const xs = state.xs(state.current.props.y);
        return xs[0] === state.current.props.x
            ? void 0
            : {
                x: xs[xs.indexOf(state.current.props.x) - 1],
                y: state.current.props.y,
            };
    }
    right() {
        if (!state.current) {
            return {
                y: state.minY,
                x: state.xs(state.minY)[0],
            };
        }
        const xs = state.xs(state.current.props.y);
        return xs[xs.length - 1] === state.current.props.x
            ? void 0
            : {
                x: xs[xs.indexOf(state.current.props.x) + 1],
                y: state.current.props.y,
            };
    }
    up() {
        if (!state.current) {
            return {
                y: state.maxY,
                x: state.xs(state.maxY)[0],
            };
        }
        const y = array_1.seek(state.ys, state.ys.indexOf(state.current.props.y) - 1);
        const xs = state.xs(y);
        if (xs[0] >= state.current.props.x) {
            return { y, x: xs[0] };
        }
        if (xs[xs.length - 1] <= state.current.props.x) {
            return { y, x: xs[xs.length - 1] };
        }
        for (let i = 1; i < xs.length; i++) {
            if (xs[i] === state.current.props.x) {
                return { y, x: xs[i] };
            }
            if (xs[i] > state.current.props.x) {
                return {
                    y,
                    x: xs[i] - state.current.props.x > state.current.props.x - xs[i - 1]
                        ? xs[i - 1]
                        : xs[i],
                };
            }
        }
        return;
    }
    down() {
        if (!state.current) {
            return {
                y: state.minY,
                x: state.xs(state.minY)[0],
            };
        }
        const y = array_1.seek(state.ys, state.ys.indexOf(state.current.props.y) + 1);
        const xs = state.xs(y);
        if (xs[0] >= state.current.props.x) {
            return { y, x: xs[0] };
        }
        if (xs[xs.length - 1] <= state.current.props.x) {
            return { y, x: xs[xs.length - 1] };
        }
        for (let i = 1; i < xs.length; i++) {
            if (xs[i] === state.current.props.x) {
                return { y, x: xs[i] };
            }
            if (xs[i] > state.current.props.x) {
                return {
                    y,
                    x: xs[i] - state.current.props.x > state.current.props.x - xs[i - 1]
                        ? xs[i - 1]
                        : xs[i],
                };
            }
        }
        return;
    }
    handleInput(data) {
        if (state.ys.length === 0) {
            return;
        }
        let pos = undefined;
        switch (data.toString()) {
            case ARROW_UP:
                pos = this.up();
                break;
            case ARROW_DOWN:
                pos = this.down();
                break;
            case ARROW_LEFT:
                pos = this.left();
                break;
            case ARROW_RIGHT:
                pos = this.right();
                break;
            default:
                return;
        }
        if (!pos) {
            return;
        }
        const item = state.get(pos.x, pos.y);
        if (state.current === item) {
            return;
        }
        if (state.current) {
            state.current.setState({ focused: false });
        }
        if (item) {
            item.setState({ focused: true });
        }
        state.current = item;
    }
    componentDidMount() {
        mobx_1.runInAction(() => {
            state.container = this;
            this.setRawMode && this.setRawMode(true);
            this.stdin.setMaxListeners(1000);
            this.stdin.on('data', this.handleInput);
        });
    }
    componentWillUnmount() {
        mobx_1.runInAction(() => {
            if (state.container === this) {
                state.container = consts_1.ANY;
            }
            this.setRawMode && this.setRawMode(false);
            this.stdin.removeListener('data', this.handleInput);
        });
    }
    render() {
        return (React.createElement(ink_1.StdinContext.Consumer, null, ({ stdin, setRawMode }) => {
            this.stdin = this.stdin || stdin;
            this.setRawMode = setRawMode;
            return this.props.children;
        }));
    }
}
tslib_1.__decorate([
    mobx_1.action.bound
], FocusableContainer.prototype, "handleInput", null);
exports.FocusableContainer = FocusableContainer;
