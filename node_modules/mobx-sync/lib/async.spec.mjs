/*!
 *
 * Copyright 2017 - acrazing
 *
 * @author acrazing joking.young@gmail.com
 * @since 2017-11-28 18:39:59
 * @version 1.0.0
 * @desc example.ts
 */
import { __awaiter, __decorate, __extends, __generator } from "tslib";
import * as assert from 'assert';
import { observable } from 'mobx';
import { sleep } from 'monofile-utilities/lib/sleep';
import { AsyncTrunk } from './async';
import { ignore, version } from './decorators';
import { KeyNodeVersion, KeyVersions } from './keys';
import { MemoryStorage } from './memory-storage';
import { toJSON } from './utils';
var N1 = /** @class */ (function () {
    function N1() {
        this.int = 1;
        this.map = observable.map();
        this.list = observable.array();
        this.vStr = 'vStr';
        this.vMap = observable.map();
        this.vList = observable.array();
    }
    __decorate([
        observable
    ], N1.prototype, "int", void 0);
    __decorate([
        version(1),
        observable
    ], N1.prototype, "vStr", void 0);
    __decorate([
        version(2)
    ], N1.prototype, "vMap", void 0);
    __decorate([
        version(3)
    ], N1.prototype, "vList", void 0);
    N1 = __decorate([
        version(4)
    ], N1);
    return N1;
}());
var N2 = /** @class */ (function () {
    function N2() {
        this.hello = 'world';
        this.ignored = 'ignored';
    }
    __decorate([
        observable
    ], N2.prototype, "hello", void 0);
    __decorate([
        ignore, observable
    ], N2.prototype, "ignored", void 0);
    return N2;
}());
var N3 = /** @class */ (function () {
    function N3() {
        this.none = 'none';
    }
    return N3;
}());
var Nm = /** @class */ (function () {
    function Nm() {
        this.version = 'version';
    }
    __decorate([
        version(4)
    ], Nm.prototype, "version", void 0);
    return Nm;
}());
var Root = /** @class */ (function () {
    function Root() {
        this.n1 = new N1();
        this.n2 = new N2();
        this.n3 = new N3();
        this.nm = new Nm();
    }
    __decorate([
        version(5)
    ], Root.prototype, "n2", void 0);
    __decorate([
        ignore
    ], Root.prototype, "n3", void 0);
    return Root;
}());
var root = new Root();
var storage = new MemoryStorage();
var t1 = new AsyncTrunk(root, { storage: storage });
describe('async trunk', function () {
    it('should be ignored', function () {
        var n2 = new N2();
        assert.deepStrictEqual(toJSON(n2), { hello: 'world' });
    });
    it('version control', function () {
        var _a, _b, _c, _d;
        assert.deepStrictEqual(toJSON(root), (_a = {
                n1: (_b = {
                        int: 1,
                        map: {},
                        list: [],
                        vStr: 'vStr',
                        vMap: {},
                        vList: []
                    },
                    _b[KeyVersions] = (_c = {},
                        _c[KeyNodeVersion] = 4,
                        _c.vStr = 1,
                        _c.vMap = 2,
                        _c.vList = 3,
                        _c),
                    _b),
                n2: {
                    hello: 'world',
                },
                nm: (_d = {},
                    _d[KeyVersions] = {
                        version: 4,
                    },
                    _d.version = 'version',
                    _d)
            },
            _a[KeyVersions] = {
                n2: 5,
            },
            _a));
    });
    it('init', function () { return __awaiter(void 0, void 0, void 0, function () {
        var N4, N5, root2, t2;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, t1.init()];
                case 1:
                    _a.sent();
                    root.n1.map.set('1', 2);
                    root.n1.list.push(3);
                    root.n1.vList.push(4);
                    root.n2.hello = '5';
                    root.n3.none = '6';
                    root.n1.vMap.set('7', 8);
                    root.nm.version = 'changed version';
                    return [4 /*yield*/, sleep(100)];
                case 2:
                    _a.sent();
                    t1.disposer();
                    N4 = /** @class */ (function (_super) {
                        __extends(N4, _super);
                        function N4() {
                            return _super !== null && _super.apply(this, arguments) || this;
                        }
                        N4 = __decorate([
                            version(6)
                        ], N4);
                        return N4;
                    }(N1));
                    N5 = /** @class */ (function (_super) {
                        __extends(N5, _super);
                        function N5() {
                            var _this = _super !== null && _super.apply(this, arguments) || this;
                            _this.version = 'new version';
                            return _this;
                        }
                        __decorate([
                            version(5)
                        ], N5.prototype, "version", void 0);
                        return N5;
                    }(Nm));
                    root2 = new Root();
                    root2.n1 = new N4();
                    root2.nm = new N5();
                    root2.n2.hello = '5';
                    t2 = new AsyncTrunk(root2, { storage: storage });
                    return [4 /*yield*/, t2.init()];
                case 3:
                    _a.sent();
                    return [4 /*yield*/, sleep(100)];
                case 4:
                    _a.sent();
                    assert.deepStrictEqual(toJSON(root2.n1), toJSON(new N4()));
                    assert.deepStrictEqual(toJSON(root2.n2), toJSON(root.n2));
                    assert.deepStrictEqual(toJSON(root2.n3), { none: 'none' });
                    assert.deepStrictEqual(toJSON(root2.nm), toJSON(new N5()));
                    return [2 /*return*/];
            }
        });
    }); });
    it('should auto run', function () { return __awaiter(void 0, void 0, void 0, function () {
        var Node, store, storage, trunk;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    Node = /** @class */ (function () {
                        function Node() {
                            this.hello = 'world 2';
                        }
                        __decorate([
                            observable
                        ], Node.prototype, "hello", void 0);
                        return Node;
                    }());
                    store = { node: new Node() };
                    storage = new MemoryStorage(true);
                    trunk = new AsyncTrunk(store, { storage: storage, storageKey: 'key' });
                    return [4 /*yield*/, trunk.init()];
                case 1:
                    _a.sent();
                    store.node.hello = 'John';
                    return [4 /*yield*/, sleep(100)];
                case 2:
                    _a.sent();
                    store.node.hello = 'John 2';
                    assert.deepStrictEqual(JSON.parse(storage.getItem('key')), {
                        node: { hello: 'John 2' },
                    });
                    return [2 /*return*/];
            }
        });
    }); });
    it('should persist array', function () { return __awaiter(void 0, void 0, void 0, function () {
        var Node, store, storage, trunk;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    Node = /** @class */ (function () {
                        function Node() {
                            this.list = [{ a: '1', b: '2' }];
                        }
                        __decorate([
                            observable
                        ], Node.prototype, "list", void 0);
                        return Node;
                    }());
                    store = new Node();
                    storage = new MemoryStorage(true);
                    trunk = new AsyncTrunk(store, { storage: storage, storageKey: 'key' });
                    return [4 /*yield*/, trunk.init()];
                case 1:
                    _a.sent();
                    store.list.push({ a: '3', b: '4' });
                    return [4 /*yield*/, sleep(100)];
                case 2:
                    _a.sent();
                    assert.deepStrictEqual(JSON.parse(storage.getItem('key')), {
                        list: [{ a: '1', b: '2' }, { a: '3', b: '4' }],
                    });
                    store.list = [];
                    return [4 /*yield*/, sleep(100)];
                case 3:
                    _a.sent();
                    assert.strictEqual(storage.getItem('key'), '{"list":[]}');
                    return [2 /*return*/];
            }
        });
    }); });
});
//# sourceMappingURL=async.spec.js.map