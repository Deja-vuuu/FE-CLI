"use strict";
/*!
 * Copyright 2018 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2018-06-27 00:25:38
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var config_1 = require("./config");
var inject_1 = require("./inject");
var keys_1 = require("./keys");
/**
 * define a custom stringify/parse function for a field, it is useful for
 * builtin objects, just like Date, TypedArray, etc.
 *
 * @example
 *
 * // this example shows how to format a date to timestamp,
 * // and load it from serialized string,
 * // if the date is invalid, will not persist it.
 * class SomeStore {
 *   @format<Date, number>(
 *      (timestamp) => new Date(timestamp),
 *      (date) => date ? +date : void 0,
 *   )
 *   dateField = new Date()
 * }
 *
 * @param deserializer - the function to parse the serialized data to
 *      custom object, the first argument is the data serialized by
 *      `serializer`, and the second is the current value of the field.
 * @param serializer - the function to serialize the object to pure js
 *      object or any else could be stringify safely by `JSON.stringify`.
 */
function format(deserializer, serializer) {
    return function (target, propertyKey) {
        inject_1.inject(target, keys_1.KeyFormat);
        target[keys_1.KeyFormat][propertyKey] = { deserializer: deserializer, serializer: serializer };
    };
}
exports.format = format;
/**
 * The short hand for format date to ISO string
 *
 * @example
 *
 * class FooStore {
 *   @date
 *   dateField = new Date()
 * }
 */
exports.date = format(function (value) { return new Date(value); });
/**
 * the short hand for format RegExp
 */
exports.regexp = format(function (value) { return new RegExp(value.source, value.flags); }, function (value) { return ({ flags: value.flags, source: value.source }); });
function _ignore(target, propertyKey) {
    inject_1.inject(target, keys_1.KeyIgnores);
    target[keys_1.KeyIgnores][propertyKey] = true;
}
/**
 * ignore the field, which means: if serialize the current store, it will
 * be omitted, and if the previous version does not omit it, will also
 * be omitted when call `parseStore`.
 *
 * Note: if set current runtime as ssr, will do nothing.
 *
 * @example
 *
 * class FooStore {
 *   @ignore
 *   bigTable = observable.map()
 * }
 *
 * @param target
 * @param propertyKey
 */
function ignore(target, propertyKey) {
    if (config_1.options.ssr) {
        return;
    }
    _ignore(target, propertyKey);
}
exports.ignore = ignore;
/**
 * same to `ignore`, but ignore the field even if the runtime is ssr.
 */
ignore.ssr = _ignore;
ignore.ssrOnly = function (target, propertyKey) {
    if (config_1.options.ssr) {
        _ignore(target, propertyKey);
    }
};
/**
 * set the version of the field, if the persisted data's version does not
 * equal to the current version, it will be omitted.
 *
 * @example
 *
 * class FooStore {
 *   // this means the current version of users struct is 1, if
 *   // your users's struct updated with breaking changes, you may need
 *   // to update the 1 to 2 to avoid loading the previous version's
 *   // users from localStorage.
 *   @version(1)
 *   users = observable.map()
 * }
 *
 * @param value - the version number, this should be different from all the
 *    old version when update it, a best practice is use q increment number.
 */
function version(value) {
    return function (target, key) {
        if (key === void 0) { key = keys_1.KeyNodeVersion; }
        if (typeof target === 'function') {
            target = target.prototype;
        }
        inject_1.inject(target);
        if (!target.hasOwnProperty(keys_1.KeyVersions)) {
            target[keys_1.KeyVersions] = tslib_1.__assign({}, target[keys_1.KeyVersions] || {});
        }
        target[keys_1.KeyVersions][key] = value;
    };
}
exports.version = version;
//# sourceMappingURL=decorators.js.map