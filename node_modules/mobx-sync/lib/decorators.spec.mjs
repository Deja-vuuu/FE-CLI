/*!
 * Copyright 2018 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2018-06-27 00:31:58
 */
import { __decorate, __extends } from "tslib";
import * as assert from 'assert';
import { observable } from 'mobx';
import { nonenumerable } from 'monofile-utilities/lib/nonenumerable';
import { config } from './config';
import { date, ignore, regexp, version } from './decorators';
import { KeyNodeVersion, KeyVersions } from './keys';
import { parseStore } from './parse-store';
import { toJSON } from './utils';
describe('decorator:format', function () {
    it('format date/regexp', function () {
        var time = new Date();
        var reg = /abc/gimu;
        var N = /** @class */ (function () {
            function N() {
                this.date = time;
                this.reg = reg;
            }
            __decorate([
                date
            ], N.prototype, "date", void 0);
            __decorate([
                regexp
            ], N.prototype, "reg", void 0);
            return N;
        }());
        var n = new N();
        assert.deepStrictEqual(toJSON(n), {
            date: time.toISOString(),
            reg: { source: reg.source, flags: reg.flags },
        });
        var data = JSON.parse(JSON.stringify(n));
        var store = new N();
        store.date = new Date(0);
        store.reg = /def/giu;
        assert.notDeepEqual(toJSON(store), toJSON(n));
        parseStore(store, data, false);
        assert.deepStrictEqual(store, n);
    });
});
describe('decorator:ignore', function () {
    it('should be ignored', function () {
        var Node = /** @class */ (function () {
            function Node() {
                this.n0 = 'n0';
                this.ignored = 'ignored';
                this.normal = 'normal';
            }
            __decorate([
                observable
            ], Node.prototype, "n0", void 0);
            __decorate([
                ignore, observable
            ], Node.prototype, "ignored", void 0);
            __decorate([
                observable
            ], Node.prototype, "normal", void 0);
            return Node;
        }());
        var node = new Node();
        assert.deepStrictEqual(toJSON(node), { normal: 'normal', n0: 'n0' });
    });
    it('should not working with nonenumerable', function () {
        var Node = /** @class */ (function () {
            function Node() {
                this.n0 = 'n0';
                this.n1 = 'n1';
                this.n2 = 'n2';
                this.n3 = 'n3';
            }
            __decorate([
                observable
            ], Node.prototype, "n0", void 0);
            __decorate([
                nonenumerable, observable
            ], Node.prototype, "n1", void 0);
            __decorate([
                observable
            ], Node.prototype, "n2", void 0);
            __decorate([
                nonenumerable
            ], Node.prototype, "n3", void 0);
            return Node;
        }());
        assert.deepStrictEqual(toJSON(new Node()), {
            n0: 'n0',
            n1: 'n1',
            n2: 'n2',
        });
    });
});
describe('decorator:ignore:ssr', function () {
    beforeEach(function () { return config({ ssr: true }); });
    afterEach(function () { return config({ ssr: false }); });
    it('should not ignore with ssr', function () {
        var Node = /** @class */ (function () {
            function Node() {
                this.onlyClientIgnored = 'onlyClientIgnored';
                this.ssrIgnored = 'ssrIgnored';
            }
            __decorate([
                ignore, observable
            ], Node.prototype, "onlyClientIgnored", void 0);
            __decorate([
                ignore.ssr, observable
            ], Node.prototype, "ssrIgnored", void 0);
            return Node;
        }());
        var node = new Node();
        assert.deepStrictEqual(toJSON(node), {
            onlyClientIgnored: 'onlyClientIgnored',
        });
        var data = new Node();
        data.onlyClientIgnored = 'new value';
        data.ssrIgnored = 'new value';
        parseStore(node, toJSON(data), true);
        assert.strictEqual(node.onlyClientIgnored, 'new value');
        assert.strictEqual(node.ssrIgnored, 'ssrIgnored');
    });
});
describe('decorator:version', function () {
    var Node = /** @class */ (function () {
        function Node() {
            this.id = 0;
        }
        __decorate([
            version(1)
        ], Node.prototype, "id", void 0);
        Node = __decorate([
            version(2)
        ], Node);
        return Node;
    }());
    var node = new Node();
    it('should persist versions', function () {
        var _a, _b;
        assert.deepStrictEqual(toJSON(node), (_a = {},
            _a[KeyVersions] = (_b = { id: 1 }, _b[KeyNodeVersion] = 2, _b),
            _a.id = 0,
            _a));
    });
    it('should persist versions with extends', function () {
        var _a;
        var P = /** @class */ (function () {
            function P() {
                this.p = 1;
            }
            __decorate([
                version(1)
            ], P.prototype, "p", void 0);
            return P;
        }());
        var C = /** @class */ (function (_super) {
            __extends(C, _super);
            function C() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.c = 2;
                return _this;
            }
            __decorate([
                version(2)
            ], C.prototype, "c", void 0);
            return C;
        }(P));
        var c = new C();
        assert.deepStrictEqual(toJSON(c), (_a = {
                p: 1,
                c: 2
            },
            _a[KeyVersions] = {
                p: 1,
                c: 2,
            },
            _a));
    });
});
//# sourceMappingURL=decorators.spec.js.map