/*!
 * Copyright 2018 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2018-06-27 00:21:42
 */
import { __values } from "tslib";
export function isPrimitive(value) {
    if (value === void 0 || value === null) {
        return true;
    }
    var type = typeof value;
    return type === 'string' || type === 'number' || type === 'boolean';
}
export function toJSON(data, recursive) {
    if (recursive === void 0) { recursive = true; }
    if (recursive) {
        var str = JSON.stringify(data);
        if (str === void 0) {
            return void 0;
        }
        return JSON.parse(str);
    }
    if (!data || !('toJSON' in data)) {
        return data;
    }
    return data.toJSON();
}
// TODO support es5 browsers
export function parseCycle(input, map, prefix) {
    var e_1, _a;
    if (map === void 0) { map = new Map(); }
    if (prefix === void 0) { prefix = ''; }
    if (isPrimitive(input)) {
        return [];
    }
    if (!map.has(input)) {
        map.set(input, [prefix || '.']);
    }
    try {
        for (var _b = __values(Object.entries(input)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var item = _c.value;
            if (isPrimitive(item[1]) || Object.keys(item[1]).length === 0) {
                continue;
            }
            var subPrefix = prefix + '.' + item[0];
            if (!map.has(item[1])) {
                map.set(item[1], [subPrefix]);
                parseCycle(item[1], map, subPrefix);
            }
            else {
                map.get(item[1]).push(subPrefix);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    if (prefix !== '') {
        return [];
    }
    var output = [];
    map.forEach(function (value, key) {
        if (value.length > 1) {
            output.push([key, value]);
        }
    });
    return output;
}
//# sourceMappingURL=utils.js.map