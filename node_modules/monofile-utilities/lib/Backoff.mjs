/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-03-01 16:06:42
 */
import { __awaiter, __generator, __read, __spread } from "tslib";
import { shuffle } from 'lodash';
import { sleep } from './sleep';
export var algorithms = {
    linear: function (index, count, base, values) {
        return base;
    },
    exponential: function (index, count, base, values) {
        return Math.pow(2, index) * base;
    },
    fibonacci: function (index, count, base, values) {
        return index < 2 ? base : values[index - 1] + values[index - 2];
    },
};
/**
 * A simple backoff algorithm, just compute next value, if end, get undefined
 */
var Backoff = /** @class */ (function () {
    function Backoff(retryCount, baseValue, mode) {
        if (retryCount === void 0) { retryCount = 10; }
        if (baseValue === void 0) { baseValue = 100; }
        if (mode === void 0) { mode = 'fibonacci'; }
        this.values = new Array(retryCount);
        for (var i = 0; i < retryCount; i++) {
            this.values[i] = algorithms[mode](i, retryCount, baseValue, this.values);
        }
        this.values.reverse();
    }
    Backoff.prototype.shuffle = function () {
        shuffle(this.values);
        return this;
    };
    Backoff.prototype.next = function () {
        return this.values.pop();
    };
    Backoff.prototype.exec = function (fn) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function () {
            var next, error, e_1, e_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        next = this.next();
                        if (next === void 0) {
                            return [2 /*return*/, fn.apply(void 0, __spread(args))];
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, fn.apply(void 0, __spread(args))];
                    case 2: return [2 /*return*/, (_a.sent())];
                    case 3:
                        e_1 = _a.sent();
                        error = e_1;
                        return [3 /*break*/, 4];
                    case 4:
                        if (!next) return [3 /*break*/, 10];
                        return [4 /*yield*/, sleep(next)];
                    case 5:
                        _a.sent();
                        _a.label = 6;
                    case 6:
                        _a.trys.push([6, 8, , 9]);
                        return [4 /*yield*/, fn.apply(void 0, __spread(args))];
                    case 7: return [2 /*return*/, (_a.sent())];
                    case 8:
                        e_2 = _a.sent();
                        error = e_2;
                        return [3 /*break*/, 9];
                    case 9:
                        next = this.next();
                        return [3 /*break*/, 4];
                    case 10: throw error;
                }
            });
        });
    };
    return Backoff;
}());
export { Backoff };
//# sourceMappingURL=Backoff.js.map