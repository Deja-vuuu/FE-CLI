"use strict";
/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-02-10 20:39:59
 *
 * Double linked list
 */
Object.defineProperty(exports, "__esModule", { value: true });
class DoubleLinkItem {
    constructor() { }
}
exports.DoubleLinkItem = DoubleLinkItem;
class DoubleLinkNode {
    constructor(value) {
        this.value = value;
    }
}
exports.DoubleLinkNode = DoubleLinkNode;
class DoubleLink {
    constructor() {
        this.head = undefined;
        this.count = 0;
    }
    has(item) {
        return item.list === this;
    }
    assertBelong(item, allowDangle) {
        if ((!item.list && !allowDangle) || (item.list && item.list !== this)) {
            throw new ReferenceError('operating item does not belong to current list');
        }
    }
    drop(item) {
        this.assertBelong(item, false);
        this.count -= 1;
        if (this.count === 0) {
            this.head = item.prev = item.next = item.list = void 0;
            return;
        }
        if (item === this.head) {
            this.head = item.next;
        }
        item.next.prev = item.prev;
        item.prev.next = item.next;
        item.prev = item.next = item.list = void 0;
    }
    prepare(item) {
        if (item.list) {
            item.prev.next = item.next;
            item.next.prev = item.prev;
        }
        else {
            ['list', 'prev', 'next'].forEach((key) => {
                Object.defineProperty(item, key, {
                    enumerable: false,
                    configurable: true,
                    writable: true,
                    value: void 0,
                });
            });
            item.list = this;
            item.prev = item.next = item;
            this.count += 1;
        }
        if (!this.head) {
            this.head = item;
        }
    }
    prepend(item) {
        this.assertBelong(item, true);
        if (this.head === item) {
            return;
        }
        this.prepare(item);
        if (this.head === item) {
            return;
        }
        this.head.prev.next = item;
        item.prev = this.head.prev;
        item.next = this.head;
        this.head.prev = item;
        this.head = item;
    }
    append(item) {
        this.assertBelong(item, true);
        if (this.head && this.head.prev === item) {
            return;
        }
        this.prepare(item);
        if (this.head === item) {
            return;
        }
        this.head.prev.next = item;
        item.prev = this.head.prev;
        item.next = this.head;
        this.head.prev = item;
    }
    forEach(callback) {
        if (!this.head) {
            return;
        }
        let index = 0;
        let item = this.head;
        while (callback(item, index++) !== false) {
            if ((item = item.next) === this.head) {
                break;
            }
        }
    }
    map(callback) {
        const r = [];
        this.forEach((item, index) => r.push(callback(item, index)));
        return r;
    }
    find(callback) {
        let item = void 0;
        this.forEach((item1, index) => {
            if (callback(item1, index)) {
                item = item1;
                return false;
            }
            return true;
        });
        return item;
    }
    items(count = 0) {
        if (count === 0) {
            return this.map((item) => item);
        }
        const r = [];
        this.forEach((item, index) => {
            if (index >= count) {
                return false;
            }
            r.push(item);
            return;
        });
        return r;
    }
}
exports.DoubleLink = DoubleLink;
//# sourceMappingURL=DoubleLink.js.map