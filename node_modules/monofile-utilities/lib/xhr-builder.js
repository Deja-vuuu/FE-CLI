"use strict";
/*!
 * Copyright 2018 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2018-07-30 17:38:17
 */
Object.defineProperty(exports, "__esModule", { value: true });
const consts_1 = require("./consts");
const detect_ie_1 = require("./detect-ie");
const is_1 = require("./is");
const query_string_1 = require("./query-string");
function formatUrl(url, dropQuery) {
    if (/{[^}]+}/.test(url)) {
        return (query, body) => {
            return url.replace(/{([^}]+)}/g, (_, $1) => {
                const [name, defaults] = $1.split(':');
                if (body && name in body) {
                    const value = body[name];
                    if (dropQuery === true || dropQuery === 'body') {
                        delete body[name];
                    }
                    return value;
                }
                if (query && name in query) {
                    const value = query[name];
                    if (dropQuery === true || dropQuery === 'query') {
                        delete query[name];
                    }
                    return value;
                }
                if (defaults !== void 0) {
                    return defaults;
                }
                throw new Error(`path parameter "${name}" is required!`);
            });
        };
    }
    return () => url;
}
class XhrError extends Error {
    constructor(status = 0, code = 0, stage = 'init', message = '') {
        super(message);
        Object.setPrototypeOf && Object.setPrototypeOf(this, new.target.prototype);
        this.name = 'XMLHttpRequestError';
        this.status = status;
        this.code = code;
        this.stage = stage;
        this.message = message;
    }
}
exports.XhrError = XhrError;
class XhrBuilder {
    constructor({ host, headers = {}, dropQuery = false, contentType = 'application/json', hijackIE = true, handleUnexpectedStatus = (xhr) => {
        return new XhrError(xhr.status, 0, 'response', 'invalid response status');
    }, parseResponseText = (text) => {
        if (!text) {
            return void 0;
        }
        return JSON.parse(text);
    }, handleResponseData = consts_1.noop, withCredentials = true, }) {
        this.host =
            typeof host === 'function'
                ? host
                : (url) => {
                    return url.indexOf('http://') === 0 || url.indexOf('https://') === 0
                        ? url
                        : `${host}${url}`;
                };
        this.config = {
            headers,
            dropQuery,
            contentType,
            hijackIE,
            handleUnexpectedStatus,
            parseResponseText,
            handleResponseData,
            withCredentials,
        };
    }
    build(method, url, options = {}) {
        method = method.toUpperCase();
        const withBody = method === 'POST' || method === 'PUT' || method === 'PATCH';
        options.headers = options.headers || {};
        const { dropQuery, handleResponseData, parseResponseText, handleUnexpectedStatus, contentType, withCredentials, } = Object.assign(Object.assign({}, this.config), options);
        const headers = Object.assign(Object.assign({}, this.config.headers), options.headers);
        const api = formatUrl(this.host(url), dropQuery);
        return (input, query) => {
            return new Promise((resolve, reject) => {
                query = withBody ? query : input;
                const body = withBody ? input : void 0;
                const xhr = new XMLHttpRequest();
                let url = query_string_1.appendQuery(api(query, body), query);
                if (this.config.hijackIE && detect_ie_1.isIE) {
                    url = query_string_1.appendQuery(url, { _: +new Date() });
                }
                xhr.open(method, url, true);
                xhr.withCredentials = withCredentials;
                for (const key in headers) {
                    if (headers.hasOwnProperty(key)) {
                        xhr.setRequestHeader(key, headers[key]);
                    }
                }
                let bodyData = null;
                if (withBody && body) {
                    let content;
                    if (is_1.isFormData(body)) {
                        bodyData = body;
                        content = 'multipart/formdata';
                    }
                    else if (is_1.isBlob(body) || is_1.isBufferSource(body)) {
                        bodyData = body;
                        content = 'application/octet-stream';
                    }
                    else if (typeof body === 'string') {
                        bodyData = body;
                        content = 'text/plain';
                    }
                    else if (contentType === 'application/json') {
                        bodyData = JSON.stringify(body);
                        content = contentType;
                    }
                    else {
                        bodyData = query_string_1.stringify(body);
                        content = contentType;
                    }
                    xhr.setRequestHeader('Content-Type', content);
                }
                xhr.onabort = () => {
                    reject(new XhrError(0, 0, 'request', 'aborted'));
                };
                xhr.ontimeout = () => {
                    reject(new XhrError(0, 0, 'request', 'timeout'));
                };
                xhr.onerror = (err) => {
                    reject(new XhrError(0, 0, 'request', err.toString()));
                };
                xhr.onload = () => {
                    if (xhr.status < 200 || xhr.status > 299) {
                        reject(handleUnexpectedStatus(xhr));
                        return;
                    }
                    try {
                        const raw = parseResponseText(xhr.responseText, xhr);
                        try {
                            const data = handleResponseData(raw) || raw;
                            resolve(data);
                        }
                        catch (e) {
                            reject(e instanceof XhrError
                                ? e
                                : new XhrError(xhr.status, 0, 'process', e.message));
                        }
                    }
                    catch (e) {
                        reject(e instanceof XhrError
                            ? e
                            : new XhrError(xhr.status, 0, 'parse', e.message));
                    }
                };
                xhr.send(bodyData);
            }).catch((e) => {
                if (e instanceof XhrError) {
                    throw e;
                }
                else {
                    throw new XhrError(0, 0, 'init', e.message);
                }
            });
        };
    }
    get(url, options) {
        return this.build('get', url, options);
    }
    delete(url, options) {
        return this.build('delete', url, options);
    }
    head(url, options) {
        return this.build('head', url, options);
    }
    options(url, options) {
        return this.build('options', url, options);
    }
    post(url, options) {
        return this.build('post', url, options);
    }
    put(url, options) {
        return this.build('put', url, options);
    }
    patch(url, options) {
        return this.build('patch', url, options);
    }
}
exports.XhrBuilder = XhrBuilder;
//# sourceMappingURL=xhr-builder.js.map