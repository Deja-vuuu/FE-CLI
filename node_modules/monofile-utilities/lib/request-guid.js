"use strict";
/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-01-17 12:14:56
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const egoroof_blowfish_1 = tslib_1.__importDefault(require("egoroof-blowfish"));
const consts_1 = require("./consts");
const ip_1 = require("./ip");
exports.GUID_RE = /^[\dA-F]{8}-[\dA-F]{8}-[\dA-F]{8}-[\dA-F]{8}$/;
function isGuid(guid) {
    return exports.GUID_RE.test(guid);
}
exports.isGuid = isGuid;
function fish(secret) {
    return new egoroof_blowfish_1.default(typeof secret === 'string' ? Buffer.from(secret, 'hex') : secret, egoroof_blowfish_1.default.MODE.CBC, egoroof_blowfish_1.default.PADDING.NULL);
}
const iv = Buffer.allocUnsafe(8);
const ip = Buffer.allocUnsafe(8);
const cipher = Buffer.allocUnsafe(8);
function createEncoder(secret) {
    const bf = fish(secret);
    let index = 0;
    return (localIP, remoteIP) => {
        if (++index > consts_1.UINT32_MAX) {
            index = 0;
        }
        const timestamp = Math.floor(Date.now() / 1e3);
        iv.writeUInt32BE(index, 0);
        iv.writeUInt32BE(timestamp, 4);
        localIP = typeof localIP === 'number' ? localIP : ip_1.ip2int(localIP, 0);
        remoteIP =
            typeof remoteIP === 'number' ? remoteIP : ip_1.ip2int(remoteIP, consts_1.UINT32_MAX);
        ip.writeUInt32BE(localIP, 0);
        ip.writeUInt32BE(remoteIP, 4);
        bf.setIv(iv);
        cipher.set(bf.encode(ip));
        return (iv
            .slice(0, 4)
            .toString('hex')
            .toUpperCase() +
            '-' +
            iv
                .slice(4)
                .toString('hex')
                .toUpperCase() +
            '-' +
            cipher
                .slice(0, 4)
                .toString('hex')
                .toUpperCase() +
            '-' +
            cipher
                .slice(4)
                .toString('hex')
                .toUpperCase());
    };
}
exports.createEncoder = createEncoder;
function createDecoder(secret) {
    const bf = fish(secret);
    return (guid, friendly2) => {
        const [index, timestamp, localIP, remoteIP] = guid.split('-', 4);
        iv.write(index + timestamp, 0, 8, 'hex');
        cipher.write(localIP + remoteIP, 0, 8, 'hex');
        bf.setIv(iv);
        ip.fill(0);
        ip.set(bf.decode(cipher, egoroof_blowfish_1.default.TYPE.UINT8_ARRAY));
        if (friendly2) {
            return {
                index: iv.readUInt32BE(0),
                timestamp: new Date(iv.readUInt32BE(4) * 1e3).toISOString(),
                localIP: ip_1.int2ip(ip.readUInt32BE(0)),
                remoteIP: ip_1.int2ip(ip.readUInt32BE(4)),
            };
        }
        else {
            return {
                index: iv.readUInt32BE(0),
                timestamp: iv.readUInt32BE(4),
                localIP: ip.readUInt32BE(0),
                remoteIP: ip.readUInt32BE(4),
            };
        }
    };
}
exports.createDecoder = createDecoder;
//# sourceMappingURL=request-guid.js.map