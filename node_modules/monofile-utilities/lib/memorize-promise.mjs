/*!
 * Copyright 2018 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2018-08-30 20:02:51
 */
import { __read, __spread } from "tslib";
import { __assign } from 'tslib';
var Rejected = /** @class */ (function () {
    function Rejected(reason) {
        this.reason = reason;
    }
    return Rejected;
}());
export { Rejected };
/**
 * memoize promise version
 * @param creator
 * @param mode
 * @param getKey
 */
export function memorizePromise(creator, mode, getKey) {
    if (mode === void 0) { mode = 'once-success'; }
    if (getKey === void 0) { getKey = String; }
    var caches = {};
    var proto = {
        cache: caches,
        has: function (key) { return caches.hasOwnProperty(key); },
        status: function (key) {
            return caches.hasOwnProperty(key)
                ? caches[key] instanceof Promise
                    ? 'pending'
                    : caches[key] instanceof Rejected
                        ? 'rejected'
                        : 'fulfilled'
                : 'unknown';
        },
        get: function (key) {
            return !caches.hasOwnProperty(key) ||
                caches[key] instanceof Promise ||
                caches[key] instanceof Rejected
                ? void 0
                : caches[key];
        },
        remove: function (key) { return delete caches[key]; },
        clear: function () { return (caches = proto.cache = {}); },
        keys: function () { return Object.keys(caches); },
    };
    var func = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var key = getKey.apply(void 0, __spread(args));
        if (!caches[key]) {
            var ret = (caches[key] = Promise.resolve(creator.apply(void 0, __spread(args))));
            switch (mode) {
                case 'once':
                    ret.then(function (data) { return (caches[key] = data); }, function (reason) { return (caches[key] = new Rejected(reason)); });
                    break;
                case 'once-success':
                    ret.then(function (data) { return (caches[key] = data); }, function () { return delete caches[key]; });
                    break;
                case 'parallel':
                    ret.then(function () { return delete caches[key]; }, function () { return delete caches[key]; });
                    break;
            }
        }
        return caches[key];
    };
    return __assign(func, proto);
}
//# sourceMappingURL=memorize-promise.js.map