/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-01-17 14:07:02
 */
import { __read } from "tslib";
import { UINT32_MAX } from './consts';
import { ip2int, IP_MAX, IP_MIN } from './ip';
import { createDecoder, createEncoder, isGuid } from './request-guid';
describe('request guid', function () {
    it('should encode/decode guid as expected', function () {
        var secret = Buffer.allocUnsafe(8);
        var cases = [
            [['127.0.0.1', void 0, '127.0.0.1', void 0], []],
            [
                ['::1', 0, '::1', UINT32_MAX],
                [IP_MIN, 0, IP_MAX, UINT32_MAX],
            ],
            [['255.255.255.255', void 0, '0.0.0.0', void 0], []],
            [
                ['1.2.3.4', void 0, '::1', UINT32_MAX],
                [void 0, void 0, IP_MAX, UINT32_MAX],
            ],
        ];
        var fixedTs = 0x12345678;
        var fixedIso = new Date(fixedTs * 1e3).toISOString();
        Date.now = function () { return fixedTs * 1e3; };
        var encoder = createEncoder(secret);
        var decoder = createDecoder(secret);
        cases.forEach(function (_a, count) {
            var _b = __read(_a, 2), _c = __read(_b[0], 4), inputLocalIP = _c[0], _d = _c[1], inputLocalInt = _d === void 0 ? ip2int(inputLocalIP) : _d, inputRemoteIP = _c[2], _e = _c[3], inputRemoteInt = _e === void 0 ? ip2int(inputRemoteIP) : _e, _f = __read(_b[1], 4), _g = _f[0], outputLocalIP = _g === void 0 ? inputLocalIP : _g, _h = _f[1], outputLocalInt = _h === void 0 ? inputLocalInt : _h, _j = _f[2], outputRemoteIP = _j === void 0 ? inputRemoteIP : _j, _k = _f[3], outputRemoteInt = _k === void 0 ? inputRemoteInt : _k;
            [
                encoder(inputLocalIP, inputRemoteIP),
                encoder(inputLocalInt, inputRemoteInt),
            ].forEach(function (guid, child) {
                var index = count * 2 + child + 1;
                expect(isGuid(guid)).toBe(true);
                expect(guid.substr(0, 8)).toBe(index.toString(16).padStart(8, '0'));
                var data = decoder(guid);
                var friendly = decoder(guid, true);
                expect(data.index).toBe(index);
                expect(data.timestamp).toBe(fixedTs);
                expect(data.localIP).toBe(outputLocalInt);
                expect(data.remoteIP).toBe(outputRemoteInt);
                expect(friendly.index).toBe(index);
                expect(friendly.timestamp).toBe(fixedIso);
                expect(friendly.localIP).toBe(outputLocalIP);
                expect(friendly.remoteIP).toBe(outputRemoteIP);
            });
        });
    });
});
//# sourceMappingURL=request-guid.spec.js.map