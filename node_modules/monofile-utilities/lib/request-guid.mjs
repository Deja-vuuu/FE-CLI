/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-01-17 12:14:56
 */
import { __read } from "tslib";
import Blowfish from 'egoroof-blowfish';
import { UINT32_MAX } from './consts';
import { int2ip, ip2int } from './ip';
export var GUID_RE = /^[\dA-F]{8}-[\dA-F]{8}-[\dA-F]{8}-[\dA-F]{8}$/;
export function isGuid(guid) {
    return GUID_RE.test(guid);
}
function fish(secret) {
    return new Blowfish(typeof secret === 'string' ? Buffer.from(secret, 'hex') : secret, Blowfish.MODE.CBC, Blowfish.PADDING.NULL);
}
var iv = Buffer.allocUnsafe(8);
var ip = Buffer.allocUnsafe(8);
var cipher = Buffer.allocUnsafe(8);
export function createEncoder(secret) {
    var bf = fish(secret);
    var index = 0;
    return function (localIP, remoteIP) {
        if (++index > UINT32_MAX) {
            index = 0;
        }
        var timestamp = Math.floor(Date.now() / 1e3);
        iv.writeUInt32BE(index, 0);
        iv.writeUInt32BE(timestamp, 4);
        localIP = typeof localIP === 'number' ? localIP : ip2int(localIP, 0);
        remoteIP =
            typeof remoteIP === 'number' ? remoteIP : ip2int(remoteIP, UINT32_MAX);
        ip.writeUInt32BE(localIP, 0);
        ip.writeUInt32BE(remoteIP, 4);
        bf.setIv(iv);
        cipher.set(bf.encode(ip));
        return (iv
            .slice(0, 4)
            .toString('hex')
            .toUpperCase() +
            '-' +
            iv
                .slice(4)
                .toString('hex')
                .toUpperCase() +
            '-' +
            cipher
                .slice(0, 4)
                .toString('hex')
                .toUpperCase() +
            '-' +
            cipher
                .slice(4)
                .toString('hex')
                .toUpperCase());
    };
}
export function createDecoder(secret) {
    var bf = fish(secret);
    return function (guid, friendly2) {
        var _a = __read(guid.split('-', 4), 4), index = _a[0], timestamp = _a[1], localIP = _a[2], remoteIP = _a[3];
        iv.write(index + timestamp, 0, 8, 'hex');
        cipher.write(localIP + remoteIP, 0, 8, 'hex');
        bf.setIv(iv);
        ip.fill(0);
        ip.set(bf.decode(cipher, Blowfish.TYPE.UINT8_ARRAY));
        if (friendly2) {
            return {
                index: iv.readUInt32BE(0),
                timestamp: new Date(iv.readUInt32BE(4) * 1e3).toISOString(),
                localIP: int2ip(ip.readUInt32BE(0)),
                remoteIP: int2ip(ip.readUInt32BE(4)),
            };
        }
        else {
            return {
                index: iv.readUInt32BE(0),
                timestamp: iv.readUInt32BE(4),
                localIP: ip.readUInt32BE(0),
                remoteIP: ip.readUInt32BE(4),
            };
        }
    };
}
//# sourceMappingURL=request-guid.js.map