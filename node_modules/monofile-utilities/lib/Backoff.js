"use strict";
/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-03-01 16:06:42
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const lodash_1 = require("lodash");
const sleep_1 = require("./sleep");
exports.algorithms = {
    linear: (index, count, base, values) => {
        return base;
    },
    exponential: (index, count, base, values) => {
        return Math.pow(2, index) * base;
    },
    fibonacci: (index, count, base, values) => {
        return index < 2 ? base : values[index - 1] + values[index - 2];
    },
};
/**
 * A simple backoff algorithm, just compute next value, if end, get undefined
 */
class Backoff {
    constructor(retryCount = 10, baseValue = 100, mode = 'fibonacci') {
        this.values = new Array(retryCount);
        for (let i = 0; i < retryCount; i++) {
            this.values[i] = exports.algorithms[mode](i, retryCount, baseValue, this.values);
        }
        this.values.reverse();
    }
    shuffle() {
        lodash_1.shuffle(this.values);
        return this;
    }
    next() {
        return this.values.pop();
    }
    exec(fn, ...args) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let next = this.next();
            if (next === void 0) {
                return fn(...args);
            }
            let error;
            try {
                return (yield fn(...args));
            }
            catch (e) {
                error = e;
            }
            while (next) {
                yield sleep_1.sleep(next);
                try {
                    return (yield fn(...args));
                }
                catch (e) {
                    error = e;
                }
                next = this.next();
            }
            throw error;
        });
    }
}
exports.Backoff = Backoff;
//# sourceMappingURL=Backoff.js.map