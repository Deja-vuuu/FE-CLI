/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-01-15 11:28:33
 */

import { configure, observable } from 'mobx';
import { asyncAction } from './asyncAction';

configure({
  enforceActions: 'always',
});

const noop = () => void 0;

describe('async action factory', () => {
  it('should run in action as expected', async () => {
    const value = observable({ v: 1 });
    const func = asyncAction(
      (i: number) => Promise.resolve(i ** 2),
      (v) => (value.v = v),
    );
    expect(func.state.status).toBe('initial');
    expect(func.state.initial).toBe(true);
    expect(func.state.pending).toBe(false);
    expect(func.state.fulfilled).toBe(false);
    expect(func.state.rejected).toBe(false);
    const result = func(2);
    expect(func.state.status).toBe('pending');
    expect(func.state.initial).toBe(false);
    expect(func.state.pending).toBe(true);
    expect(func.state.fulfilled).toBe(false);
    expect(func.state.rejected).toBe(false);
    await result;
    expect(value.v).toBe(2 ** 2);
    expect(func.state.status).toBe('fulfilled');
    expect(func.state.initial).toBe(false);
    expect(func.state.pending).toBe(false);
    expect(func.state.fulfilled).toBe(true);
    expect(func.state.rejected).toBe(false);
  });

  it('should reject if rejected without handler', async () => {
    const func1 = asyncAction((i: number) => Promise.reject(i ** 2), noop);
    await expect(func1(2)).rejects.toBe(4);
    expect(func1.state.lastError).toBe(4);
    const func2 = asyncAction(
      (i: number) => Promise.reject(i ** 2),
      noop,
      noop,
    );
    await expect(func2(2)).resolves.toBeUndefined();
  });
});
