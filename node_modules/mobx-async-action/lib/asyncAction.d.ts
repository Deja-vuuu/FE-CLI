/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-01-15 10:28:40
 */
export declare type AsyncStatus = 'initial' | 'pending' | 'fulfilled' | 'rejected';
export interface AsyncAction<I extends any[], O> {
    (...input: I): O;
    readonly state: {
        readonly status: AsyncStatus;
        readonly lastError: any;
        readonly initial: boolean;
        readonly pending: boolean;
        readonly fulfilled: boolean;
        readonly rejected: boolean;
    };
}
export interface AsyncActionOptions {
}
/**
 * create a async action wrapper for mobx
 *
 * @example
 * class TodoStore {
 *   todos = []
 *
 *   fetchTodos = asyncAction(
 *     () => fetch('/todos').then((r) => r.json()),
 *     (todos) => this.todos = todos,
 *     () => void 0,
 *   )
 * }
 *
 * @param executor    - the asynchronous executor, returns data need to be
 *                      handled, this is required and must return a Promise,
 *                      or else you do not need use this.
 * @param onFulfilled - run in action when executor fulfilled, the argument is
 *                      the result of executor, this is required, you do not
 *                      need to wrap the function by mobx.action, this is
 *                      wrapped automatically by the handler.
 * @param onRejected  - run in action when executor rejected, the argument is
 *                      the reason of executor. this is not required, if not
 *                      passed, the function will reject if executor rejected.
 * @param _options    - nothing currently
 */
export declare function asyncAction<I extends any[], R, O>(executor: (...input: I) => Promise<R>, onFulfilled: (result: R) => O, onRejected?: ((reason: any) => any) | null, _options?: AsyncActionOptions): AsyncAction<I, O>;
