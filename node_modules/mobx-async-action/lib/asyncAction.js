"use strict";
/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-01-15 10:28:40
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var mobx_1 = require("mobx");
/**
 * create a async action wrapper for mobx
 *
 * @example
 * class TodoStore {
 *   todos = []
 *
 *   fetchTodos = asyncAction(
 *     () => fetch('/todos').then((r) => r.json()),
 *     (todos) => this.todos = todos,
 *     () => void 0,
 *   )
 * }
 *
 * @param executor    - the asynchronous executor, returns data need to be
 *                      handled, this is required and must return a Promise,
 *                      or else you do not need use this.
 * @param onFulfilled - run in action when executor fulfilled, the argument is
 *                      the result of executor, this is required, you do not
 *                      need to wrap the function by mobx.action, this is
 *                      wrapped automatically by the handler.
 * @param onRejected  - run in action when executor rejected, the argument is
 *                      the reason of executor. this is not required, if not
 *                      passed, the function will reject if executor rejected.
 * @param _options    - nothing currently
 */
function asyncAction(executor, onFulfilled, onRejected, _options) {
    if (onRejected === void 0) { onRejected = null; }
    if (_options === void 0) { _options = {}; }
    var func;
    var state = mobx_1.observable({
        status: 'initial',
        lastError: undefined,
        get initial() {
            return this.status === 'initial';
        },
        get pending() {
            return this.status === 'pending';
        },
        get fulfilled() {
            return this.status === 'fulfilled';
        },
        get rejected() {
            return this.status === 'rejected';
        },
    });
    var _onFulfilled = mobx_1.action(function (result) {
        state.status = 'fulfilled';
        return onFulfilled(result);
    });
    var _onRejected = mobx_1.action(function (reason) {
        state.status = 'rejected';
        state.lastError = reason;
        return onRejected ? onRejected(reason) : Promise.reject(reason);
    });
    func = mobx_1.action(function () {
        var input = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            input[_i] = arguments[_i];
        }
        state.status = 'pending';
        return executor.apply(void 0, tslib_1.__spread(input)).then(_onFulfilled, _onRejected);
    });
    Object.assign(func, { state: state });
    return func;
}
exports.asyncAction = asyncAction;
//# sourceMappingURL=asyncAction.js.map